# MJ -- I have commented this up to what I think the eventual
#       interface should be.  Not everything is implemented yet.
#       I use *** at the start of the lines where I have written
#       something here that isn't implemented yet in the code.


##########################################################################
#
# Parameters related to logging, debugging, etc.
#
# verbose = 0 means no debug output, 1 = some, 2 = all
verbose	= 1
#
# If debug_file is set, that file is used for output.
# Otherwise, std::cout is used.
# You may instead specify debug_ext which will use root.debug_ext as the 
# debug file.
#debug_file = measurepsf.debug
#debug_ext = .psfdebug
#
# If output_dots is set, it will output status dots to stderr as the 
# calculation proceeds as well as some simple text to indicate progress.
#output_dots = true
#
# If timing is set, it will output information about the calculation time.
#timing = true
#
##########################################################################


##########################################################################
#
# Parameters to define the names of the various files involved:
#
# The names of the file may be specified completely by these parameters:
#
#image_file = [name of image file]
#weight_file = [name of weight file]
#cat_file = [name of original sextractor catalog file]
#dist_file = [name of file defining the distortion function]
#stars_file = [name of catalog file indicated which objects are stars]
#psf_file = [name of psf shapelet catalog file]
#fitpsf_file = [name of file defining psf interpolation function]
#shear_file = [name of shear catalog file]
#log_file = [name of the log file] (else use stdout)
#
# However, these parameters are rarely the most convenient, since 
# each of them has the same root name with different extensions.
# Since the root changes for each run of the code, you would need to
# spectify all of these file names on the command line, leading to 
# extremely long command lines.
#
# It is usually easier to define only the root name on the command line
# and use standard extensions for the different files.  So, 
# image_file = root + image_ext.  Likewise for the other names.
#
# A slight wrinkle to this scheme is that the files may be in different
# directories, so you may need to add some prefix before root in the 
# file name.  So,
#
# image_file = image_prefix + root + image_ext 
#
# Each prefix and ext may be specified separately.
# For convenience, we make it a bit easier for the file structure 
# that DES uses where:
# image, weight, cat and dist are in one directory, given by input_prefix.
# The other files are in a different directory, given by output_prefix.
# So, if image_prefix is not defined, the code checks for input_prefix,
# and if that is not defined then no prefix is used.
# 
# Note: Any . or / that needs to be part of the name needs to be part of
# the prefix or root or ext.  This makes the naming scheme more flexible,
# since one might want to use prefix for something other than a directory.
# And ext might start with an _ rather than a .
#
# Also, sometimes it is convenient to allow for multiple possible
# extensions for the input files.  These may be specified sequentially,
# separated by white space.  The program will try each extension in 
# order until if finds an existing file. 
#
# *** If multiple extensions are provided for an output file, the code
# *** will output to all of them.  This can be useful to write output in
# *** multiple formats, such as a fits file and a text file.
# *** MJ - not implemented yet.
#
# *** Finally, if root is not specified, either all *_file parameters 
# *** need to be explicitly defined, or the code will try to calculate
# *** root from the provided image_file and its prefix and ext.
# *** MJ -- not implemented yet.
#
#root = [Usually given on the command line]
image_ext = .fits .fits.fz .fits.gz
cat_ext = _cat.fits
weight_ext = .fits .fits.fz .fits.gz
#dist_ext = .undfunc2			# for dist_method = FUNC2D
dist_ext = .fits .fits.fz .fits.gz	# for dist_method = WCS
# *** MJ - I think the name of _all doesn't make sense anymore, since
#          we removed the other catalog with only stars.
#          In fact, I think starcat or stars would be sensible for 
#          this suffix, since this catalog indicates which objects
#          are stars.  But I'm not changing it now, since I don't want
#          to break any currently working scripts.
stars_ext = _all.fits
psf_ext = _psf.fits
fitpsf_ext = _fitpsf.fits
shear_ext = _shear.fits
#
#input_prefix = ./
#output_prefix = ./
#image_prefix = ./		# default is input_prefix
#cat_prefix = ./		# default is input_prefix
#weight_prefix = ./		# default is input_prefix
#dist_prefix = ./		# default is input_prefix
#stars_prefix = ./		# default is output_prefix
#psf_prefix = ./		# default is output_prefix
#fitpsf_prefix = ./		# default is output_prefix
#shear_prefix = ./		# default is output_prefix
#
# Fits files may use an hdu != 1.  If so, they may be specified here:
# The default is 1 for image, weight, and dist.
# The defautl is 2 for cat, fs, psf, fitpsf, and shear.
#
image_hdu = 2
cat_hdu = 3
weight_hdu = 4
dist_hdu = 2
stars_hdu = 2
psf_hdu = 2
fitpsf_hdu = 2
shear_hdu = 2
#
# *** The default I/O format for catalogs is determined from the 
# *** appropriate _ext parameter.
# *** If it is or contains "fits", then we use FITS I/O
# *** If it is or contains "csv", then we use TEXT I/O with delim = ,
# *** If it is anything else, then we use TEXT I/O with delim = "  "
# *** You can override this behavior by specifying either FITS or TEXT
# *** for the _io parameter and the appropriate delimiter as _delim.
# *** MJ - not implemented yet.
#
#cat_io = FITS
#stars_io = FITS
#psf_io = FITS
#fitpsf_io = FITS
#shear_io = FITS
#cat_delim = ,
#stars_delim = ,
#psf_delim = ,
#shear_delim = ,
log_delim = ,
#
##########################################################################


##########################################################################
# 
# Parameters for input catalog:
#
#
# If cat_io == FITS (or cat_ext contains "fits"), then these define
# the column names for each catalog item that we need:
#
cat_id_name = number
cat_x_name = x_image
cat_y_name = y_image
cat_local_sky_name = background
cat_mag_name = mag_auto
cat_mag_err_name = magerr_auto
# *** MJ -- Add possibility of noise in FITS file
#cat_noise_num = sigsky  
cat_flags_name = flags
cat_ra_name = alpha_j2000
cat_dec_name = delta_j2000
#
# If cat_io == TEXT (or cat_ext does not contain "fits"), then these
# define the column number for each catalog item that we need.
# So cat_x_num = 3 means the third item in each row is x.
# The only required values are x, y, mag, and mag_err.
# The others are optional or may be required depending on what you
# set for other parameters.
# (Note: all the other catalogs are written by us, so we have a standard
#        order of the values in TEXT I/O that is not changeable, so
#        this is the only catalog with _num parameters.)
#cat_id_num = 1
#cat_x_num = 2
#cat_y_num = 3
#cat_local_sky_num = 4
#cat_mag_num = 5
#cat_mag_err_num = 6
#cat_noise_num = 7
#cat_flags_num = 8
#cat_ra_num = 9
#cat_dec_num = 10
#
# If the flags column is given, then we ignore input objects with 
# flags if (flags & ~ok_flags) = true.
# Or, you may specify instead errorcodes to avoid with ignore_flags
# in which case objects with (flags & ignore_flags) = true are skipped.
# *** MJ -- This is only implemented for TEXT Input.
cat_ok_flags = 0
#cat_ignore_flags = -1
#
# Lines in the (TEXT) input file to skip can be specified by an initial
# guard token.  The default is # as in this file, but a different one 
# may be specified by the parameter cat_comment_marker.
# (More than one may be specified, separated by white space.)
#cat_comment_marker = !
#
# Sometimes there is an offset between the catlog definition of x,y
# and a zero-based C-style view of the pixel array.
# If this is the case, you can specify the offset here.
#cat_x_offset = 1
#cat_y_offset = 1
#
# If the sky value is not given in the catalog, it can be specified here
# (or on the command line, since it varies from one exposure to another).
# If neither cat_sky nor cat_sky_num (or cat_sky_name as appropriate)
# are given, then the code assumes that the sky value has been subtracted
# from the images (eg. images that have been swarp-ed) and thus has a 
# value of 0.
#cat_sky = 2000.
#
# If the input catalog has too few rows, then findstars has no chance of
# working.  This mostly guards against strange input conditions with 0
# rows or something like that.  100 should be a reasonable choice here.
cat_minrows = 100
#cat_minrows = 100
#
##########################################################################


##########################################################################
#
# Parameters for Findstars:
#
# entries in the findstars catalog
# If stars_io == FITS (or stars_ext contains "fits"), then these define
# the column names for each catalog item that we need:
stars_id_name = id
stars_sigma0_name = sigma0
stars_size_flags_name = size_flags
stars_star_flag_name = star_flag
#
# If stars_io == TEXT (or stars_ext does not contain "fits"), then the
# values are written as 4 columns in the above order.
# 
# There are a bunch of parameters defining how the findstars algorithm 
# works.  Unfortunately is a bit of an art getting this correct for
# a given survey.  We have tried to give meaningful names to make it 
# easier to figure out what a reasonable choice for each parameter is.
# However, we usually need to look at the debug output
# for inputs that don't produce a good stellar solution to figure
# out how to tweak the parameters for better results.
#
# Some basic parameters defining which input objects to use:
#
stars_minsize =		0.2	# The min size to consider
stars_maxsize =		5.	# The max size to consider
# These are for the SExtractor mags with wrong zeropoint
stars_minmag =		10.0	# The min magnitude to consider
stars_maxmag =		14	# The max magnitude to consider
stars_maxoutmag =	12	# The max magnitude to include in output
#
# Parameters for the first pass through catalog when the whole
# region is divided into subdivisions
#
stars_ndivx =		1	# Number of subdivisions in x direction
stars_ndivy =		1	# Number of subdivisions in y direction
stars_startn1 =		0.15	# How many objects to start with per subdivision
                        	# as a fraction of total number of objects
stars_starfrac =	0.4	# What fraction of startn1 are probably stars
stars_magstep1 =	0.25	# Step size in magnitudes 
stars_miniter1 =	3	# Min times to step up the magnitude cutoff
stars_reject1 =		2.0	# N sigma for rejection 
stars_binsize1 =	0.1	# Bin size for histogram
stars_maxratio1 =	0.15	# Max ratio of valley count to peak count
stars_okvalcount =	2	# If valley count<=this, consider it ok
				# even if ratio>maxratio1
stars_maxrms =		0.05	# Max rms of first linear fit.
stars_starsperbin =	30	# Minimum stars to expect in each bin
#
# Parameters for the final pass through catalog 
#
stars_fitorder =	1	# Order of fitted function size(x,y)
stars_fitsigclip =	4.0	# Sigma clip when fitting size(x,y)
stars_startn2 =		0.5	# How many objects to start with 
stars_magstep2 =	0.10	# Step size in magnitudes 
stars_miniter2 =	2	# Min times to step up the magnitude cutoff
stars_minbinsize =	0.01	# Min width of histogram bins
stars_reject2 =		4.0	# N sigma for rejection 
stars_purityratio =	0.10	# Max ratio of valley count to peak count
stars_maxrefititer =	5	# Max number of times to refit size(x,y) 
#
##########################################################################


##########################################################################
#
# Parameters related to the noise
#
# The allowed methods for calculating the noise in the image are:
# VALUE, CATALOG, CATALOG_SIGMA, GAIN_VALUE, GAIN_FITS, WEIGHT_IMAGE
#
noise_method = WEIGHT_IMAGE
#
# If noise_method == VALUE:
# Then the noise is given here as a fixed value for all pixels:
#
#noise = 1.e3
#
# If noise_method == CATALOG:
# Then the noise value is read in from the input catalog.
#
#cat_noise_name = varsky
#cat_noise_num = 16
#
# If noise_method == CATALOG_SIGMA:
# Then the value sigma is read in from the input catalog.
# The variance is sigma*sigma
#
#cat_noise_name = sigsky
#cat_noise_num = 16
#
# If noise_method == GAIN_VALUE:
# Then the noise is calculated from assuming Poisson statistics, and
# the gain and read noise values, which should be given here.
# noise_variance = (I(i,j)+extra_sky)/gain+readnoise
# where extrasky, if given here, is the sky value that was subtracted
# from the image intensities in processing.
# (If the sky has not been subtracted, leave extrasky 0 or undefined.)
#
#image_gain = 1.
#image_readnoise = 0.
#image_extra_sky = 1.e4
#
# If noise_method == GAIN_FITS:
# Then the noise is calculated as above, but the values for gain and 
# readnoise are read in from the fits file.
# The values gain_key and readnoise_key give the keys for these values 
# in the fits file.  More than one may be given, in which case, each will
# be tried until one is successful.
#
#image_gain_key = GAIN  ARCONG
#image_readnoise_key = RDNOISE  RON  ARCONRN
#
# If noise_method == WEIGHT_IMAGE:
# Then the noise is read in from a weight image file.
# The weight file gives the inverse noise for each pixel.
# It is taken to have the same name as the input fitsfile, but with
# (possibly) a different extension, given by weightext.
# You may also specify an HDU to use if necessary with weighthdu
#
#weight_ext = .fits
#weight_file = weightfile
#weight_hdu = 2
#
##########################################################################


##########################################################################
# 
# Parameters related to the distortion:
#
# Like with the noise, there are a number of ways to specify the 
# distortion function.  That is, the function mapping chip (x,y) values
# onto sky values in arcseconds.
#
# The allowed methods are: SCALE, JACOBIAN, FUNC2D, WCS
# 
dist_method = WCS
#
# If dist_method = SCALE, then the distortion matrix is just the identity
# matrix times a pixel size:
# ( u ) = pixel_scale * ( 1  0 ) * ( x )
# ( v )                 ( 0  1 )   ( y )
#
#pixel_scale = 0.27
# 
# If dist_method = JACOBIAN, then the distortion matrix is just given
# by the Jacobian matrix, and is a constant across the field.
#
# ( u ) = ( dudx  dudy ) * ( x )
# ( v )   ( dvdx  dvdy )   ( y )
#
#dudx = 1.
#dudy = 0.
#dvdx = 0.
#dvdy = 1.
#
# If dist_method = FUNC2D, then the distortion function is read in using
# Mike Jarvis's Function2D objects.
#
#dist_ext = .undfunc
#
# If dist_method = WCS, then the distortion function is read from 
# WCS parameters in a fits file 
#
#dist_ext = .fits.fv  .fits
#
##########################################################################


##########################################################################
#
# Parameters related to the PSF measurement:
# 
# If psf_io == FITS (or psf_ext contains "fits"), then these define
# the column names for each catalog item that we need:
psf_id_name = id
psf_flags_name = psf_flags
psf_nu_name = nu 
psf_order_name = psf_order
psf_sigma_p_name = sigma_p
psf_coeffs_name = coeffs
#
# If psf_io == TEXT (or psf_ext does not contain "fits"), then the
# values are written as 6 columns in the above order.
#
# psf_aperture = How many sigma to use for the aperture
psf_aperture = 5.
# psf_order = The order of the shapelet decomposition to be measured
#psf_order = 6
psf_order = 10
# seeing_est = An estimate of the seeing.  
# The code can easily handle actual values that are a factor of 
# two or more different from this, but if it is very very wrong,
# then it might have trouble.  The value is specified in arcsec.
psf_seeing_est = 0.9
#psf_seeing_est = 0.9
# 
##########################################################################


##########################################################################
# 
# Parameter related to the interpolation fit of the PSF:
#
# If fitpsf_io == FITS (or fitpsf_ext contains "fits"), then these define
# the column names for each catalog item that we need:
fitpsf_psf_order_name = psf_order
fitpsf_sigma_name = sigma
fitpsf_fit_order_name = fit_order
fitpsf_npca_name = npca
fitpsf_xmin_name = xmin
fitpsf_xmax_name = xmax
fitpsf_ymin_name = ymin
fitpsf_ymax_name = ymax
fitpsf_ave_psf_name = ave_psf
fitpsf_rot_matrix_name = rot_matrix
fitpsf_interp_matrix_name = interp_matrix
#
# If fitpsf_io == TEXT (or fitpsf_ext does not contain "fits"), then
# the code uses a standard text I/O for the FittedPSF class.
# Also, any fitpsf_delim specifier is ignored.
#
# fitpsf_order = The order in x,y of the fit across a chip
fitpsf_order = 2
#
# The fit involves a rotation into the principal components of the PSF
# The number of components to use is given by one of the following:
# fitpsf_npca = The number of components to use
#fitpsf_npca = 5
# fitpsf_pca_thresh = Use all components with singular values greater
#                     than fitpsf_pca_thresh * S(0)
fitpsf_pca_thresh = 1.e-3
#
##########################################################################



##########################################################################
#
# Parameters related to measuring the shear of the galaxies:
# 
# If shear_io == FITS (or shear_ext contains "fits"), then these define
# the column names for each catalog item that we need:
shear_id_name = id
shear_flags_name = shear_flags
shear_shear1_name = shear1
shear_shear2_name = shear2
shear_cov00_name = shear_cov00
shear_cov01_name = shear_cov01
shear_cov11_name = shear_cov11
shear_gal_order_name = gal_order
shear_coeffs_name = shapelets_prepsf
shear_size_flags_name = size_flags
shear_star_flag_name = star_flag
shear_sigma0_name = sigma0
#
# If shear_io == TEXT (or shear_ext does not contain "fits"), then the
# values are written as 12 columns in the above order.
#
# shear_aperture = How many sigma to use for the aperture
shear_aperture = 3.
# shear_max_aperture = The maximum size of the aperture in arcsec
shear_max_aperture = 10.
# shear_gal_order = The order of the shapelet decomposition to be measured
#                   for the deconvolved galaxies.
shear_gal_order = 6
# shear_gal_order2 = The order of the shapelet decomposition to use for
#                    the shear measurement
shear_gal_order2 = 2
# shear_min_gal_size = The minimum galaxy size to bother trying to measure the 
#                shear for.  Measured in multiples of the PSF size.
shear_min_gal_size = 1.0
# shear_f_psf = A parameter determining the sigma of the shapelet decomposition
#         sigma^2_obs = sigma^2_gal + f_psf sigma^2_psf
#         So far, only f_psf = 1 has been tested.
shear_f_psf = 1.0
#
##########################################################################


##########################################################################
#
# Miscellaneous parameters:
#
# For non-whitespace-delimited files, there is no easy string commands,
# so I needed to use character arrays for the values in each row. 
# These are usually just numbers, so they should be only about 5 or 10
# characters each.  I use a buffer of 500 characters to be "absolutely" 
# safe.  However, if you have something crazy in your input file and you 
# want to increase this you can set bufsize to be something larger.
#csv_bufsize = 500
#
# For parallel compilations, you can set the number of threads to be 
# different than the default value openmp chooses on its own.
# Well, you should be able to.... This doesn't seem to work yet.
#omp_num_threads = 2
#
##########################################################################


