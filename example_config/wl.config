
# Debugging parameters:
#
# verbose = 0 means no debug output, 1 = some, 2 = all
# If debug_file is set, that file is used for output, else std::cout is used.
# You may instead specify debug_ext which will use root.debug_ext as the 
# debug file.
#
# If output_dots is set, it will output status dots as the calculation proceeds.
# If timing is set, it will output information about the calculation time.
#
verbose	= 1
#debug_file = measurepsf.debug
#debug_ext = .psfdebug
#output_dots = 1
#time = 1

# For parallel compilations, you can set the number of threads to be 
# different than the default value openmp chooses on its own.
# Well, you should be able to.... This isn't working yet.
#num_threads = 2


# Filename parameters:
#
# The names of the file may be specified completely by these parameters:
#
#image_file = [name of image file]
#weight_file = [name of weight file]
#cat_file = [name of original sextractor catalog file]
#dist_file = [name of file defining the distortion function]
#allcat_file = [name of catalog file with all objects]
#starcat_file = [name of catalog file with stars]
#psf_file = [name of psf shapelet catalog file]
#fitpsf_file = [name of file defining psf interpolation function]
#shear_file = [name of shear catalog file]
#log_file = [name of the log file] (else use stdout)
#
# However, these parameters are rarely the most convenient, since 
# each of them has the same root name with different extensions.
# Since the root changes for each run of the code, you would need to
# spectify all of these file names on the command line, leading to 
# extremely long and confusing commands.
#
# It is usually easier to define only the root name on the command line
# and use standard extensions for the different files.  So, 
# image_file = root + image_ext.  Likewise for the other names.
#
# A slight wrinkle to this scheme is that the files may be in different
# directories, so you may need to add some prefix before root in the 
# file name.  So,
#
# image_file = image_prefix + root + image_ext 
#
# Each prefix and ext may be specified separately.
# For convenience, we make it a bit easier for the file structure 
# that DES uses where:
# image, weight, cat and dist are in one directory, specified by input_prefix.
# The other files are in a different directory, specified by output_prefix.
# So, if image_prefix is not defined, the code checks for input_prefix,
# and if that is not defined then no prefix is used.
# 
# Note: Any . or / that needs to be part of the name needs to be part of
# the prefix or root or ext.  This makes the naming scheme more flexible,
# since one might want to use prefix for something other than a directory.
# And ext might start with an _ rather than a .
#
# Also, sometimes it is convenient to allow for multiple possible extensions
# for the input files.  These may be specified sequentially, separated by
# white space.  The program will try each extension in order until if
# finds an existing file. 
#
#root = [Usually given on the command line]
#
#root=

image_ext = .fits.fz .fits
cat_ext = _cat.fits
weight_ext = .fits.fz .fits
#dist_ext = .undfunc2		# for dist_method = FUNC2D
#dist_ext = .fits.fz .fits	# for dist_method = WCS
allcat_ext = _all.csv
starcat_ext = _star.csv
psf_ext = _psf.csv
fitpsf_ext = _fitpsf.dat
shear_ext = _shear.csv
#
#input_prefix = ./
#output_prefix = ./
#image_prefix = ./		# default is input_prefix
#cat_prefix = ./		# default is input_prefix
#weight_prefix = ./		# default is input_prefix
#dist_prefix = ./		# default is input_prefix
#allcat_prefix = ./		# default is output_prefix
#starcat_prefix = ./		# default is output_prefix
#dist_prefix = ./		# default is output_prefix
#psf_prefix = ./		# default is output_prefix
#shear_prefix = ./		# default is output_prefix
#
# Fits files may use an hdu != 1.  If so, they may be specified here:
image_hdu = 2
cat_hdu = 3
weight_hdu = 4
#dist_hdu = 2
#
#
# The default is for each column in the catalog files
# to be separated by whitespace.  If you have a comma delimited file, though,
# you can specify the delimeter here:
allcat_delim = ,
starcat_delim = ,
psf_delim = ,
shear_delim = ,
log_delim = ,


# names of entries in the SExtractor catalog
sx_id_name = number
sx_x_name = x_image
sx_y_name = y_image
sx_local_sky_name = background
sx_mag_name = mag_auto
sx_mag_err_name = magerr_auto
sx_flags_name = flags

# some required things from the fits catalog
sx_minrows = 100


# entries in the findstars catalog
fs_cat_hdu = 2
fs_id_name = id
fs_sigma0_name = sigma0
fs_size_flags_name = size_flags
fs_star_flag_name = star_flag

psf_cat_hdu = 2
psf_id_name = id
psf_flags_name = psf_flags
psf_nu_name = nu 
psf_order_name = psf_order
psf_sigma_p_name = sigma_p
psf_coeffs_name = coeffs

fitpsf_cat_hdu = 2

fitpsf_psf_order_name = psf_order
fitpsf_sigma_name = sigma
fitpsf_fit_order_name = fit_order
fitpsf_npca_name = npca

fitpsf_xmin_name = xmin
fitpsf_xmax_name = xmax
fitpsf_ymin_name = ymin
fitpsf_ymax_name = ymax

fitpsf_ave_psf_name = ave_psf
fitpsf_rot_matrix_name = rot_matrix
fitpsf_interp_matrix_name = interp_matrix


shear_cat_hdu = 2
shear_id_name = id
shear_flags_name = shear_flags

shear_shear1_name = shear1
shear_shear2_name = shear2

shear_cov00_name = shear_cov00
shear_cov01_name = shear_cov01
shear_cov11_name = shear_cov11

shear_gal_order_name = gal_order
shear_coeffs_name = shapelets_prepsf

shear_size_flags_name = size_flags
shear_star_flag_name = star_flag
shear_sigma0_name = sigma0


#
# For non-whitespace-delimited files, there is no easy string commands, so
# I needed to use character arrays for the values in each row.  These are 
# usually just numbers, so they should be only about 5 or 10 characters each.
# I use a buffer of 500 characters to be "absolutely" safe.  However, if you
# have something crazy in your input file and you want to increase this you
# can set bufsize to be something larger.
#bufsize = 500


# Noise parameters:
#
# The allowed methods for calculating the noise in the image are:
# VALUE, CATALOG, CATALOG_SIGMA, GAIN_VALUE, GAIN_FITS, WEIGHT_IMAGE
#
noise_method = WEIGHT_IMAGE
#
# If noise_method == VALUE:
# Then the noise is given here as a fixed value for all pixels:
#
#noise = 1.e3
#
# If noise_method == CATALOG:
# Then the noise value is read in from the input catalog.
#
#i_noise = 16
#
# If noise_method == CATALOG_SIGMA:
# Then the value sigma is read in from the input catalog.
# The variance is sigma*sigma
#
#i_noise = 16
#
# If noise_method == GAIN_VALUE:
# Then the noise is calculated from assuming Poisson statistics, and
# the gain and read noise values, which should be given here.
# noise_variance = (I(i,j)+extra_sky)/gain+readnoise
# where extrasky, if given here, is the sky value that was subtracted
# from the image intensities in processing.
# (If the sky has not been subtracted, leave extrasky 0 or undefined.)
#
#gain = 1.
#readnoise = 0.
#extra_sky = 1.e4
#
# If noise_method == GAIN_FITS:
# Then the noise is calculated as above, but the values for gain and readnoise
# are read in from the fits file.
# The values gain_key and readnoise_key give the keys for these values 
# in the fits file.  More than one may be given, in which case, each will
# be tried until one is successful.
#
#gain_key = GAIN  ARCONG
#readnoise_key = RDNOISE  RON  ARCONRN
#
# If noise_method == WEIGHT_IMAGE:
# Then the noise is read in from a weight image file.
# The weight file gives the inverse noise for each pixel.
# It is taken to have the same name as the input fitsfile, but with
# (possibly) a different extension, given by weightext.
# You may also specify an HDU to use if necessary with weighthdu
#
#weight_ext = .fits
#weight_file = weightfile
#weight_hdu = 2


# Input catalog parameters:
# The position of each parameter in the input catalog is given by i_???
# So i_x = 3 means the third item in each row is x.
# The required values are i_x, i_y.
# The optional values are i_sky, i_errcode, i_noise.
i_x = 2
i_y = 3
i_sky = 4
#i_errcode = 14
#i_noise = 16   
#
# Lines in the input file to skip can be specified by an initial token,
# The default is # as in this file, but a different one may be specified here.
# (More than one may be specified, separated by white space.)
#comment_marker = !
#
# Sometimes there is an offset between the catlog definition of x,y
# and a zero-based C-style view of the pixel array.
# If this is the case, you can specify the offset here.
#x_offset = 1
#y_offset = 1
#
# If the sky value is not given in the catalog, it can be specified here
# (or on the command line, since it varies from one exposure to another).
# If neither sky nor i_sky are given, then the code assumes that the sky
# value has been subtracted from the images (eg. images that have been 
# swarp-ed) and thus has a value of 0.
sky = 2000.


# Distortion parameters
# Like with the noise, there are a number of ways to specify the 
# distortion function.  That is, the function mapping chip (x,y) values
# onto sky values in arcseconds.
#
# The allowed methods are: SCALE, JACOBIAN, FUNC2D, WCS_FITS
# 
dist_method = SCALE
#
# If dist_method = SCALE, then the distortion matrix is just the identity
# matrix times a pixel size:
# ( u ) = pixel_scale * ( 1  0 ) * ( x )
# ( v )                 ( 0  1 )   ( y )
#
pixel_scale = 0.27
# 
# If dist_method = JACOBIAN, then the distortion matrix is just given
# by the Jacobian matrix, and is a constant across the field.
#
# ( u ) = ( dudx  dudy ) * ( x )
# ( v )   ( dvdx  dvdy )   ( y )
#
#dudx = 1.
#dudy = 0.
#dvdx = 0.
#dvdy = 1.
#
# If dist_method = FUNC2D, then the distortion function is read in using
# Mike Jarvis's Function2D objects.
#
#dist_ext = .undfunc
#
# If dist_method = WCS, then the distortion function is read from 
# WCS parameters in a fits file 
#
#dist_ext = .fits.fv  .fits
#


# PSF parameters:
# 
# psf_aperture = How many sigma to use for the aperture
psf_aperture = 5.
# max_aperture = The maximum size of the aperture in arcsec
max_aperture = 10.
# psf_order = The order of the shapelet decomposition to be measured
#psf_order = 6
psf_order = 10
# seeing_est = An estimate of the seeing.  
# The code can easily handle actual values that are a factor of 
# two or more different from this, but if it is very very wrong,
# then it might have trouble.  The value is specified in arcsec.
seeing_est = 0.9


# Fitting PSF parameters
#
# fitpsf_order = The order in x,y of the fit across a chip
fitpsf_order = 2
# The fit involves a rotation into the principal components of the PSF
# The number of principal components to use is given by one of the following:
#
# fitpsf_npca = The number of components to use
#fitpsf_npca = 5
#
# fitpsf_pca_thresh = Use all components with singular values greater
#                     than fitpsf_pca_thresh * S(0)
fitpsf_pca_thresh = 1.e-3


# Shear parameters:
# 
# gal_aperture = How many sigma to use for the aperture
gal_aperture = 3.
# max_aperture = The maximum size of the aperture in arcsec
max_aperture = 10.
# gal_order = The order of the shapelet decomposition to be measured
gal_order = 6
# gal_order2 = The order of the shapelet decomposition to use for the shear 
#              measurement
gal_order2 = 2
# min_gal_size = The minimum galaxy size to bother trying to measure the 
#                shear for.  Measured in multiples of the PSF size.
min_gal_size = 1.0
# f_psf = A parameter determining the sigma of the shapelet decomposition
#         sigma^2_obs = sigma^2_gal + f_psf sigma^2_psf
#         So far, only f_psf = 1 has been tested.
f_psf = 1.0


# StarFinder configuration parameters
#
minsize=		0.2	# The min size to consider
maxsize	=	5.	# The max size to consider
# These are for the SExtractor mags with wrong zeropoint
minmag	=	10.0	# The min magnitude to consider
maxmag	=	14	# The max magnitude to consider
maxoutmag=	12	# The max magnitude to include in output

#xcol	=	2	# Column for x
#ycol	=	3	# Column for y
#mcol	=	4	# Column for m
#scol1	=	7	# Column for size (or first of two to add, eg. ixx)
#scol2	=	8	# Column for second component of size, eg. iyy
			# Set scol2 to 0 if you only have one size term
#ecol	=	0	# Column for error code
okerrcode=	0	# Error codes to consider "ok" 
                        # if (errcode & ~okerrcode) entry will be skipped
#baderrcode=	-1	# Can instead specify bad error codes 
                        # This sets okerrcode = ~baderrcode

# Parameters for the first pass through catalog when the whole
# region is divided into subdivisions

ndivx	=	1	# Number of subdivisions in x direction
ndivy	=	1	# Number of subdivisions in y direction
startn1	=	0.25	# How many objects to start with per subdivision
                        # as a fraction of total number of objects
starfrac=	0.3	# What fraction of catalog are probably stars
magstep1=	0.25	# Step size in magnitudes 
miniter1=	3	# Min times to step up the magnitude cutoff
reject1	=	2.0	# N sigma for rejection 
binsize1=	0.1	# Bin size for histogram
maxratio1=	0.15	# Max ratio of valley count to peak count
okvalcount=	2	# If valley count <= this, use even if ratio>maxratio1
maxrms	=	0.05	# Max rms of first linear fit.

# Parameters for the final pass through catalog 

fitorder=	1	# Order of fitted function size(x,y)
fitsigclip=	4.0	# Sigma clip when fitting size(x,y)
startn2	=	0.5	# How many objects to start with 
magstep2=	0.10	# Step size in magnitudes 
miniter2=	2	# Min times to step up the magnitude cutoff
minbinsize=0.01	  # Min width of histogram bins
reject2	=	4.0	# N sigma for rejection 
purityratio=	0.10	# Max ratio of valley count to peak count
maxrefititer=	5	# Max number of times to refit size(x,y) 

starsperbin = 5
